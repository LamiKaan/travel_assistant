import os
import sys
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "..")))

from datetime import datetime
import sqlite3

from typing import Type, Optional, List, Dict, Any, Union, Annotated
from pydantic import BaseModel, Field, field_validator

from langchain_core.tools import BaseTool, InjectedToolArg
from langchain_core.tools.base import ArgsSchema
from langchain_core.messages import ToolMessage

from flight_assistant.data.setup_mock_flight_data import normalize_city_name
from flight_assistant.utils import pretty_print_object



# Schema for the input to the flight search tool
class FlightSearchInput(BaseModel):
    # Ellipsis (...) indicates that the field is required (but a default value is not specified)
    # InjectedToolArg --> There are cases where certain arguments need to be passed to a tool at runtime but should not be generated by the model itself. For this, we use the InjectedToolArg annotation, which allows certain parameters to be hidden from the tool's schema. (source: langchain docs)
    tool_call_id: Annotated[str, InjectedToolArg] = Field(..., description="Unique identifier for the tool call")
    from_city: str = Field(..., description="Departure city")
    to_city: str = Field(..., description="Arrival city")
    flight_type: str = Field(..., description='Trip type: must be "one-way" or "two-way"')
    depart_date: str = Field(..., description="Depart date in YYYY-MM-DD format")
    return_date: Optional[str] = Field(None, description="Return date in YYYY-MM-DD format (if two-way trip), or None")

    # Validator (enforces a specific format) for `flight_type`
    @field_validator("flight_type", mode="plain")
    def validate_flight_type(cls, value):
        if value not in {"one-way", "two-way"}:
            raise ValueError('flight_type must be either "one-way" or "two-way"')
        
        return value

    # Validator for `departure_date` and `return_date`
    @field_validator("depart_date", "return_date", mode="after")
    def validate_date_format(cls, value):
        # Return-date can be None
        if value is None:
            return None
        
        try:
            # Ensure the date is strictly in YYYY-MM-DD format
            datetime.strptime(value, "%Y-%m-%d")
        except ValueError:
            raise ValueError("Date must be in YYYY-MM-DD format")
        
        return value
    


class FlightSearchTool(BaseTool):
    name: str = "search_flights"
    description: str = "Finds available flights based on flight information provided by user."
    args_schema: Type[BaseModel] = FlightSearchInput
    # response_format: str = "content_and_artifact"

    def _query_database(self, query: str, params: tuple) -> List[Dict[str, Any]]:
        """Executes a SQL query and fetches results."""

        # Path to the database file
        current_dir = os.path.dirname(os.path.abspath(__file__))
        database_path = os.path.abspath(os.path.join(current_dir, "..", "data", "db", "flight_database.db"))

        # Establish a connection to the database
        connection = sqlite3.connect(database_path)  # Connect to the database
        cursor = connection.cursor()

        # Execute the query, fetch results, and close the connection
        cursor.execute(query, params)
        rows = cursor.fetchall()
        connection.close()

        # print(type(rows))
        # print(rows)

        # Convert query results to structured output
        flights = [
            {"airline": row[4], 
             "departure_time": row[5], 
             "arrival_time": row[6], 
             "duration": row[7],
             "class": row[8], 
             "price": row[9], 
             "flight_code": row[10]}
            for row in rows
        ]

        return flights


    def _run(
        self,
        tool_call_id,
        from_city,
        to_city,
        flight_type,
        depart_date,
        return_date = None,
    ) -> Union[ Dict[str, List[Dict[str, Any]]], ToolMessage]:
        """Retrieve structured flight details from the database."""

        # Initialize the dictionary to store the retieved flight details
        results = {"depart_flights": [], "return_flights": []}

        # Define the SQL query to retrieve flights from the database
        query = """
        SELECT *
        FROM flights
        WHERE date = ? AND from_city = ? AND to_city = ?
        ORDER BY departure_time ASC
        ;
        """

        # Normalize city names for query search
        from_city = normalize_city_name(from_city)
        to_city = normalize_city_name(to_city)

        try:
            # Query the database for depart flights and store the results
            depart_flights = self._query_database(query, (depart_date, from_city, to_city))
            results["depart_flights"] = depart_flights

            # Query return flights if it's a two-way trip
            if flight_type == "two-way" and return_date is not None:
                return_flights = self._query_database(query, (return_date, to_city, from_city))
                results["return_flights"] = return_flights

            
            # --- ERROR HANDLING ---
            # Case 1: No depart flights found
            if len(depart_flights) == 0:
                # Return a tool response message indicating that no flights are available
                content = f"""No flights could be retrieved for the given user input. Note that the system is only capable of searching for domestic flights within Turkey until the end of 2025 calendar year (2025-12-31), and continue assisting the user also by taking the system capabilities into account (if that seems as the cause of the unsuccessful tool call)."""
                return ToolMessage(
                    tool_call_id=tool_call_id,
                    content=content,
                    status="error",
                )
            
            # Case 2: Return flights are requested but not found
            if flight_type == "two-way" and len(return_flights) == 0:
                # Return a tool response message indicating that no return flights are available
                content = f"""Even though depart flights could be retrieved, no return flights could be retrieved for the given user input. Note that the system is only capable of searching for domestic flights within Turkey until the end of 2025 calendar year (2025-12-31), and continue assisting the user also by taking the system capabilities into account (if that seems as the cause of the unsuccessful tool call)."""
                return ToolMessage(
                    tool_call_id=tool_call_id,
                    content=content,
                    status="error",
                )
            
            # Default case where flights are successfully retrieved (no error)
            return results


        except Exception as e:
            # In case of code execution errors that are unrelated to the system logic (e.g. failed to connect to the database, api server didn't respond etc.)
            content = f"""An error occurred while trying to retrieve flight information. The error message is: {str(e)}. Problem may disappear if tried again; but if it still persists, contacting the system administrator might be necessary. Please continue assisting the user appropriately."""
            return ToolMessage(
                tool_call_id=tool_call_id,
                content=content,
                status="error",
            )



if __name__ == "__main__":
    
    flight_search_tool = FlightSearchTool()

    # output = flight_search_tool.invoke({
    #     "name": "search_flights",
    #     "args": {"from_city": "Istanbul", "to_city": "Ä°zmir", "flight_type": "two-way", "depart_date": "2025-05-19", "return_date": "2025-10-10"},
    #     "id": "123",  # required
    #     "type": "tool_call",  # required
    # })

    tool_call = {
        "name": "search_flights",
        "args": {"from_city": "Ankara", "to_city": "istanbul", "flight_type": "two-way", "depart_date": "2025-09-18", "return_date": "2025-11-10"},
        "id": "123",
        "type": "tool_call",
    }

    tool_call["status"] = "approved"

    tool_call["args"] = {"tool_call_id": tool_call["id"], **tool_call["args"]}
    # tool_call["args"] = {**tool_call["args"], "tool_call_id": tool_call["id"]}

    args = tool_call["args"]
    args = {"tool_call_id": tool_call["id"], **args}

    print(tool_call)

    output = flight_search_tool.invoke(tool_call)

    print("---------------------------------------")
    print(f"Output type:\n\n {type(output)}\n\n")
    print(f"Content type:\n\n {type(output.content)}\n\n")
    print("---------------------------------------")
    print(f"Output:\n\n {output}\n\n")
    print(f"Status:\n\n {output.status}\n\n")
    # pretty_print_object(output)
    # print("\n")
    print("---------------------------------------")
    print(f"Output instance variables:\n\n {output.__dict__.keys()}\n\n")